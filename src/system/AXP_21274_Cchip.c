/*
 * Copyright (C) Jonathan D. Belanger 2018.
 * All Rights Reserved.
 *
 * This software is furnished under a license and may be used and copied only
 * in accordance with the terms of such license and with the inclusion of the
 * above copyright notice.  This software or any other copies thereof may not
 * be provided or otherwise made available to any other person.  No title to
 * and ownership of the software is hereby transferred.
 *
 * The information in this software is subject to change without notice and
 * should not be construed as a commitment by the author or co-authors.
 *
 * The author and any co-authors assume no responsibility for the use or
 * reliability of this software.
 *
 * Description:
 *
 *	This module contains the code for the Tsunami/Typhoon Cchip.  The Cchip
 *	performs the following functions:
 *		- Accepts requests from the Pchips and the CPUs
 *		- Orders the arriving requests as required
 *		- Selects among the requests to issue controls to the DRAMs
 *		- Issues probes to the CPUs as appropriate to the selected requests
 *		- Translates CPU PIO addresses to PCI and CSR addresses
 *		- Issues commands to the Pchip as appropriate to the selected (PIO or
 *		  PTP) requests
 *		- Issues responses to the Pchip and CPU as appropriate to the issued
 *		  requests
 *		- Issues controls to the Dchip as appropriate to the DRAM accesses, and
 *		  the probe and Pchip responses
 *		- Controls the TIGbus to manage interrupts, and maintains CSRs
 *		  including those that represent interrupt status
 *	The Tsunami supports up to 2 CPUs and the Typhoon supports up to 4 CPUs.
 *
 * Revision History:
 *
 *	V01.000		18-Mar-2018	Jonathan D. Belanger
 *	Initially written.
 */
#include "AXP_21274_System.h"
#include "AXP_21274_Cchip.h"
#include "AXP_21274_21264_Common.h"
#include "AXP_21274_AddressMapping.h"

/*
 * AXP_21274_ReadCSR
 *	This function is called when a request request has come in for a CSR.
 *
 * Input Parameters:
 *	sys:
 *		A pointer to the system data structure from which the emulation
 *		information is maintained.
 *	pa:
 *		The Physical Address that contains the CSR to be read.
 *	cpuID:
 *		An unsigned 32-bit value indicating the CPU requesting the read.  This
 *		is used when setting the correct ProbeEnable bit.  This can only be a
 *		value between 0 and 3.
 *
 * Output Parameters:
 *	None.
 *
 * Return Value:
 *	An unsigned  64-bit value read from the CSR.
 *
 * NOTE:	Reading from a CSR may not always be just a read.  It is possible
 *			that some other action may be generated by simply executing the
 *			read operation.
 */
u64 AXP_21274_ReadCSR(AXP_21274_SYSTEM *sys, u64 pa, u32 cpuID)
{
	AXP_21274_CSR_ADDR	csrAddr = {.addr = pa};
	int					chip = csrAddr.chip + (csrAddr.cpuAddr = 0x200e ? 1 : 0);
	u64					retVal = 0;

	/*
	 * We now know the chip and the CSR.  Let's go do what we came here to do.
	 */
	switch (chip)
	{
		case AXP_21274_PCHIP0:
			switch (csrAddr.csr)
			{
				case 0x00:			/* P0-WSBA0 */
					retVal = *((u64 *) &sys->p0Wsba0);
					break;

				case 0x01:			/* P0-WSBA1 */
					retVal = *((u64 *) &sys->p0Wsba1);
					break;

				case 0x02:			/* P0-WSBA2 */
					retVal = *((u64 *) &sys->p0Wsba2);
					break;

				case 0x03:			/* P0-WSBA3 */
					retVal = *((u64 *) &sys->p0Wsba3);
					break;

				case 0x04:			/* P0-WSM0 */
					retVal = *((u64 *) &sys->p0Wsm0);
					break;

				case 0x05:			/* P0-WSM1 */
					retVal = *((u64 *) &sys->p0Wsm1);
					break;

				case 0x06:			/* P0-WSM2 */
					retVal = *((u64 *) &sys->p0Wsm2);
					break;

				case 0x07:			/* P0-WSM3 */
					retVal = *((u64 *) &sys->p0Wsm3);
					break;

				case 0x08:			/* P0-TBA0 */
					retVal = *((u64 *) &sys->p0Tba0);
					break;

				case 0x09:			/* P0-TBA1 */
					retVal = *((u64 *) &sys->p0Tba1);
					break;

				case 0x0a:			/* P0-TBA2 */
					retVal = *((u64 *) &sys->p0Tba2);
					break;

				case 0x0b:			/* P0-TBA3 */
					retVal = *((u64 *) &sys->p0Tba3);
					break;

				case 0x0c:			/* P0-PCTL */
					retVal = *((u64 *) &sys->p0Pctl);
					break;

				case 0x0d:			/* P0-PLAT */
					retVal = *((u64 *) &sys->p0Plat);
					break;

				case 0x0f:			/* P0-PERROR */
					retVal = *((u64 *) &sys->p0Perror);
					break;

				case 0x10:			/* P0-PERRMASK */
					retVal = *((u64 *) &sys->p0PerrMask);
					break;

				case 0x14:			/* P0-PMONCTL */
					retVal = *((u64 *) &sys->p0MonCtl);
					break;

				case 0x15:			/* P0-PMONCNT */
					retVal = *((u64 *) &sys->p0MonCnt);
					break;

				default:
					/* TODO: non-existent memory */
					break;
			}
			break;
		case AXP_21274_PCHIP1:
			switch (csrAddr.csr)
			{
				case 0x00:			/* P0-WSBA0 */
					retVal = *((u64 *) &sys->p1Wsba0);
					break;

				case 0x01:			/* P0-WSBA1 */
					retVal = *((u64 *) &sys->p1Wsba1);
					break;

				case 0x02:			/* P0-WSBA2 */
					retVal = *((u64 *) &sys->p1Wsba2);
					break;

				case 0x03:			/* P0-WSBA3 */
					retVal = *((u64 *) &sys->p1Wsba3);
					break;

				case 0x04:			/* P0-WSM0 */
					retVal = *((u64 *) &sys->p1Wsm0);
					break;

				case 0x05:			/* P0-WSM1 */
					retVal = *((u64 *) &sys->p1Wsm1);
					break;

				case 0x06:			/* P0-WSM2 */
					retVal = *((u64 *) &sys->p1Wsm2);
					break;

				case 0x07:			/* P0-WSM3 */
					retVal = *((u64 *) &sys->p1Wsm3);
					break;

				case 0x08:			/* P0-TBA0 */
					retVal = *((u64 *) &sys->p1Tba0);
					break;

				case 0x09:			/* P0-TBA1 */
					retVal = *((u64 *) &sys->p1Tba1);
					break;

				case 0x0a:			/* P0-TBA2 */
					retVal = *((u64 *) &sys->p1Tba2);
					break;

				case 0x0b:			/* P0-TBA3 */
					retVal = *((u64 *) &sys->p1Tba3);
					break;

				case 0x0c:			/* P0-PCTL */
					retVal = *((u64 *) &sys->p1Pctl);
					break;

				case 0x0d:			/* P0-PLAT */
					retVal = *((u64 *) &sys->p1Plat);
					break;

				case 0x0f:			/* P0-PERROR */
					retVal = *((u64 *) &sys->p1Perror);
					break;

				case 0x10:			/* P0-PERRMASK */
					retVal = *((u64 *) &sys->p1PerrMask);
					break;

				case 0x14:			/* P0-PMONCTL */
					retVal = *((u64 *) &sys->p1MonCtl);
					break;

				case 0x15:			/* P0-PMONCNT */
					retVal = *((u64 *) &sys->p1MonCnt);
					break;

				default:
					/* TODO: non-existent memory */
					break;
			}
			break;
		case AXP_21274_CCHIP:
			switch (csrAddr.csr)
			{
				case 0x00:			/* CSC */
					retVal = *((u64 *) &sys->csc);
					break;

				case 0x01:			/* MTR */
					retVal = *((u64 *) &sys->mtr);
					break;

				case 0x02:			/* MISC */
					retVal = *((u64 *) &sys->misc);
					break;

				case 0x03:			/* MPD */
					retVal = *((u64 *) &sys->mpd);
					break;

				case 0x04:			/* AAR0 */
					retVal = *((u64 *) &sys->aar0);
					break;

				case 0x05:			/* AAR1 */
					retVal = *((u64 *) &sys->aar1);
					break;

				case 0x06:			/* AAR2 */
					retVal = *((u64 *) &sys->aar2);
					break;

				case 0x07:			/* AAR3 */
					retVal = *((u64 *) &sys->aar3);
					break;

				case 0x08:			/* DIM0 */
					retVal = *((u64 *) &sys->dim0);
					break;

				case 0x09:			/* DIM1 */
					retVal = *((u64 *) &sys->dim1);
					break;

				case 0x0a:			/* DIR0 */
					retVal = *((u64 *) &sys->dir0);
					break;

				case 0x0b:			/* DIR1 */
					retVal = *((u64 *) &sys->dir1);
					break;

				case 0x0c:			/* DRIR */
					retVal = *((u64 *) &sys->drir);
					break;

				case 0x0d:			/* PRBEN */
					switch (cpuID)
					{
						case 0:
							sys->prbEn.prben0 = 0;
							break;

						case 1:
							sys->prbEn.prben1 = 0;
							break;

						case 2:
							sys->prbEn.prben2 = 0;
							break;

						case 3:
							sys->prbEn.prben3 = 0;
							break;
					}
					break;

				case 0x0e:			/* IIC0 */
					retVal = *((u64 *) &sys->iic0);
					break;

				case 0x0f:			/* IIC1 */
					retVal = *((u64 *) &sys->iic1);
					break;

				case 0x16:			/* TTR */
					retVal = *((u64 *) &sys->ttr);
					break;

				case 0x17:			/* TDR */
					retVal = *((u64 *) &sys->tdr);
					break;

				case 0x18:			/* DIM2 */
					retVal = *((u64 *) &sys->dim2);
					break;

				case 0x19:			/* DIM3 */
					retVal = *((u64 *) &sys->dim3);
					break;

				case 0x1a:			/* DIR2 */
					retVal = *((u64 *) &sys->dir2);
					break;

				case 0x1b:			/* DIR3 */
					retVal = *((u64 *) &sys->dir3);
					break;

				case 0x1c:			/* IIC2 */
					retVal = *((u64 *) &sys->iic2);
					break;

				case 0x1d:			/* IIC3 */
					retVal = *((u64 *) &sys->iic3);
					break;

				case 0x1e:			/* PWR */
					retVal = *((u64 *) &sys->pwr);
					break;

				case 0x30:			/* CMONCTLA */
					retVal = *((u64 *) &sys->cmonctla);
					break;

				case 0x31:			/* CMONCTLB */
					retVal = *((u64 *) &sys->cmonctlb);
					break;

				case 0x32:			/* CMONCNT01 */
					retVal = *((u64 *) &sys->cmoncnt01);
					break;

				case 0x33:			/* CMONCNT23 */
					retVal = *((u64 *) &sys->cmoncnt23);
					break;

				default:
					/* TODO: non-existent memory */
					break;
			}
			break;

		case AXP_21274_DCHIP:
			switch (csrAddr.csr)
			{
				case 0x20:			/* DSC */
					retVal = *((u64 *) &sys->dsc);
					break;

				case 0x21:			/* STR */
					retVal = *((u64 *) &sys->str);
					break;

				case 0x22:			/* DREV */
					retVal = *((u64 *) &sys->dRev);
					break;

				case 0x23:			/* DSC2 */
					retVal = *((u64 *) &sys->dsc2);
					break;

			}
			break;
	}

	/*
	 * Return the results back to the caller.
	 */
	return(retVal);
}

/*
 * AXP_21274_ReadPIO
 *	This function is called on a read command (ReadBytes, ReadLWs, ReadQWs),
 *	which are always to PIO space.
 *
 * Input Parameters:
 *	sys:
 *		A pointer to the system data structure from which the emulation
 *		information is maintained.
 *	rq:
 *		A pointer to the next request to be processed.
 *
 * Output Parameters:
 *	TODO:
 *
 * Return Value:
 *	TODO:
 */
void AXP_21264_ReadPIO(AXP_21274_SYSTEM *sys, AXP_21274_RQ_ENTRY *rq)
{
	u64	csrValue;

	/*
	 * First, let's see what we are dealing with (the physical address supplied
	 * will help us determine what we need to do next).
	 *
	 * Is this one of the CSRs.
	 */
	if (AXP_21264_CSR_ADDR(rq->pa))
		csrValue = AXP_21274_ReadCSR(sys, rq->pa, rq->cpuID);
	else if (AXP_21274_LINEAR_MEMORY(rq->pa) ||
			 AXP_21274_LINEAR_IO(rq->pa) ||
			 AXP_21274_LINEAR_CFG(rq->pa) ||
			 AXP_21274_LINEAR_IACK(rq->pa))
		;
	else if (AXP_21274_TIGBUS_ADDR(rq->pa))
		;
	else
		;	/* TODO: Non-existent memory? */


	/*
	 * Return back to the caller.
	 */
	return;
}

/*
 * AXP_21274_CchipInit
 *	This function is called to initialize the Cchip CSRs as documented in HRM
 *	10.2 Chipset Registers.
 *
 * Input Parameters:
 *	sys:
 *		A pointer to the system data structure from which the emulation
 *		information is maintained.
 *
 * Output Parameters:
 *	sys:
 *		A pointer to the system data structure, with the Cchip CSRs initialized
 *		based on the HRM for Tsunami/Typhoon chip set.
 *
 * Return Values:
 *	None.
 */
void AXP_21274_CchipInit(AXP_21274_SYSTEM *sys)
{
	u32		hh, ii, jj;

	/*
	 * Initialization for CSC (HRM Table 10-10)
	 *
	 * TODO:	iddw, iddr, and aw are updated when the Dchip STR register is
	 *			written.
	 * TODO:	Byte 0 powers up to the value present on bits <7:0> of the
	 * 			TIGbus.  This includes fw, sed, c1cfp, c0cfp, and bc fields.
	 */
	sys->csc.res_63 = 0;
	sys->csc.res_62 = 0;
	sys->csc.p1w = 1;
	sys->csc.p0w = 1;
	sys->csc.res_59 = 0;
	sys->csc.pbqmax = 1;
	sys->csc.res_55 = 0;
	sys->csc.prqmax = 2;
	sys->csc.res_51 = 0;
	sys->csc.pdtmax = 1;
	sys->csc.res_47 = 0;
	sys->csc.fpqpmax = 0;
	sys->csc.res_43 = 0;
	sys->csc.fpqcmax = 1;
	sys->csc.axd = 0;
	sys->csc.tpqmmax = 1;
	sys->csc.b3d = 0;
	sys->csc.b2d = 0;
	sys->csc.b1d = 0;
	sys->csc.fti = 0;
	sys->csc.eft = AXP_EFT_1_CYCLES;
	sys->csc.qdi = AXP_QDI_DISABLE_DRAINING;
	sys->csc.fet = AXP_FET_3_CYCLE;
	sys->csc.qpm = AXP_QPM_ROUND_ROBIN;
	sys->csc.pme = 0;
	sys->csc.res_22 = 0;
	sys->csc.drtp = AXP_DRTP_5_CYCLES;
	sys->csc.dwfp = AXP_DWFP_5_CYCLES;
	sys->csc.dwtp = AXP_DWTP_5_CYCLES;
	sys->csc.res_15 = 0;
	sys->csc.pip = 1;	/* in this implementation P1 is always present */
	sys->csc.iddw = AXP_IDDW_6_CYCLES;
	sys->csc.iddr = AXP_IDDR_9_CYCLES;
	sys->csc.aw = AXP_AW_16_BYTES;
	sys->csc.fw = 0;
	sys->csc.sfd = AXP_SFD_2_CYCLES;
	sys->csc.sed = AXP_SED_2_CYCLES;
	sys->csc.c1cfp = 0;
	sys->csc.c0cfp = 0;
	sys->csc.bc = 0;

	/*
	 * Initialization for MTR (HRM Table 10-11)
	 */
	sys->mtr.res_46 = 0;
	sys->mtr.mph = 0;
	sys->mtr.phcw = 14;
	sys->mtr.phcr = 15;
	sys->mtr.res_30 = 0;
	sys->mtr.ri = 0;
	sys->mtr.mpd = 0;
	sys->mtr.res_17 = 0;
	sys->mtr.rrd = AXP_RRD_2_CYCLES;
	sys->mtr.res_14 = 0;
	sys->mtr.rpt = AXP_RPT_2_CYCLES;
	sys->mtr.res_10 = 0;
	sys->mtr.rpw = AXP_RPW_4_CYCLES;
	sys->mtr.res_7 = 0;
	sys->mtr.ird = AXP_IRD_0_CYCLES;
	sys->mtr.res_3 = 0;
	sys->mtr.cat = AXP_CAT_2_CYCLES;
	sys->mtr.res_1 = 0;
	sys->mtr.rcd = AXP_RCD_2_CYCLES;

	/*
	 * Initialization for MISC (HRM Table 10-12)
	 */
	sys->misc.res_44 = 0;
	sys->misc.devSup = 0;
	sys->misc.rev = AXP_REV_TYPHOON;
	sys->misc.nxs = AXP_NXS_CPU0;
	sys->misc.nxm = 0;
	sys->misc.res_25 = 0;
	sys->misc.acl = 0;
	sys->misc.abt = 0;
	sys->misc.abw = 0;
	sys->misc.ipreq = 0;
	sys->misc.ipintr = 0;
	sys->misc.itintr = 0;
	sys->misc.res_2 = 0;
	sys->misc.cpuID = AXP_CPUID_CPU0;

	/*
	 * Initialization for MPD (HRM Table 10-13)
	 */
	sys->mpd.res_4 = 0;
	sys->mpd.dr = AXP_MPD_SET;
	sys->mpd.ckr = AXP_MPD_SET;
	sys->mpd.ds = AXP_MPD_SET;
	sys->mpd.cks = AXP_MPD_SET;

	/*
	 * Initialization for AAR0, AAR1, AAR2, AAR3 (HRM Table 10-15)
	 */
	sys->aar0.res_35 = 0;
	sys->aar0.addr = 0;
	sys->aar0.res_17 = 0;
	sys->aar0.dbg = 0;
	sys->aar0.asiz = AXP_ASIZ_DISABLED;
	sys->aar0.res_10 = 0;
	sys->aar0.tsa = AXP_TSA_DISABLED;
	sys->aar0.sa = AXP_SA_DISABLED;
	sys->aar0.res_4 = 0;
	sys->aar0.rows = AXP_ROWS_11_BITS;
	sys->aar0.bnks = AXP_BNKS_1_BITS;

	sys->aar1.res_35 = 0;
	sys->aar1.addr = 0;
	sys->aar1.res_17 = 0;
	sys->aar1.dbg = 0;
	sys->aar1.asiz = AXP_ASIZ_DISABLED;
	sys->aar1.res_10 = 0;
	sys->aar1.tsa = AXP_TSA_DISABLED;
	sys->aar1.sa = AXP_SA_DISABLED;
	sys->aar1.res_4 = 0;
	sys->aar1.rows = AXP_ROWS_11_BITS;
	sys->aar1.bnks = AXP_BNKS_1_BITS;

	sys->aar2.res_35 = 0;
	sys->aar2.addr = 0;
	sys->aar2.res_17 = 0;
	sys->aar2.dbg = 0;
	sys->aar2.asiz = AXP_ASIZ_DISABLED;
	sys->aar2.res_10 = 0;
	sys->aar2.tsa = AXP_TSA_DISABLED;
	sys->aar2.sa = AXP_SA_DISABLED;
	sys->aar2.res_4 = 0;
	sys->aar2.rows = AXP_ROWS_11_BITS;
	sys->aar2.bnks = AXP_BNKS_1_BITS;

	sys->aar3.res_35 = 0;
	sys->aar3.addr = 0;
	sys->aar3.res_17 = 0;
	sys->aar3.dbg = 0;
	sys->aar3.asiz = AXP_ASIZ_DISABLED;
	sys->aar3.res_10 = 0;
	sys->aar3.tsa = AXP_TSA_DISABLED;
	sys->aar3.sa = AXP_SA_DISABLED;
	sys->aar3.res_4 = 0;
	sys->aar3.rows = AXP_ROWS_11_BITS;
	sys->aar3.bnks = AXP_BNKS_1_BITS;

	/*
	 * Initialization for DIM0, DIM1, DIM2, DIM3 (HRM Table 10-16)
	 */
	sys->dim0 = AXP_DIM_INTR_NONE;
	sys->dim1 = AXP_DIM_INTR_NONE;
	sys->dim2 = AXP_DIM_INTR_NONE;
	sys->dim3 = AXP_DIM_INTR_NONE;

	/*
	 * Initialization for DIR0, DIR1, DIR2, DIR3 (HRM Table 10-17)
	 */
	sys->dir0.err = 0;
	sys->dir0.res_56 = 0;
	sys->dir0.dev = 0;

	sys->dir1.err = 0;
	sys->dir1.res_56 = 0;
	sys->dir1.dev = 0;

	sys->dir2.err = 0;
	sys->dir2.res_56 = 0;
	sys->dir2.dev = 0;

	sys->dir3.err = 0;
	sys->dir3.res_56 = 0;
	sys->dir3.dev = 0;

	/*
	 * Initialization for DRIR (HRM Table 10-18)
	 */
	sys->drir = AXP_DRIR_INTR_NONE;

	/*
	 * Initialization for PRBEN (HRM Table 10-19)
	 */
	sys->prbEn.res_2 = 0;
	sys->prbEn.prben = AXP_PRBEN_DISABLED;

	/*
	 * Initialization for IIC0, IIC1, IIC2, IIC3 (HRM Table 10-20)
	 */
	sys->iic0.res_25 = 0;
	sys->iic0.of = AXP_OF_POSITIVE;
	sys->iic0.iCnt = 0;

	sys->iic1.res_25 = 0;
	sys->iic1.of = AXP_OF_POSITIVE;
	sys->iic1.iCnt = 0;

	sys->iic2.res_25 = 0;
	sys->iic2.of = AXP_OF_POSITIVE;
	sys->iic2.iCnt = 0;

	sys->iic3.res_25 = 0;
	sys->iic3.of = AXP_OF_POSITIVE;
	sys->iic3.iCnt = 0;

	/*
	 * Initialization for MPR0, MPR1, MPR2, MPR3 (HRM Table 10-22)
	 */
	sys->mpr0.res_13 = 0;
	sys->mpr0.mprdat = 0;

	sys->mpr1.res_13 = 0;
	sys->mpr1.mprdat = 0;

	sys->mpr2.res_13 = 0;
	sys->mpr2.mprdat = 0;

	sys->mpr3.res_13 = 0;
	sys->mpr3.mprdat = 0;

	/*
	 * Initialization for TTR (HRM Table 10-23)
	 */
	sys->ttr.res_15 = 0;
	sys->ttr.id = 7;
	sys->ttr.res_10 = 0;
	sys->ttr.irt = AXP_IRT_4_CYCLE;
	sys->ttr.res_6 = 0;
	sys->ttr.is = AXP_IS_4_CYCLE;
	sys->ttr.res_2 = 0;
	sys->ttr.ah = AXP_AH_1_CYCLE;
	sys->ttr.as = AXP_AS_1_CYCLE;

	/*
	 * Initialization for TDR (HRM Table 10-24)
	 */
	sys->tdr.wh3 = 0;
	sys->tdr.wp3 = 0;
	sys->tdr.res_58 = 0;
	sys->tdr.ws3 = 0;
	sys->tdr.res_55 = 0;
	sys->tdr.ra3 = 0;

	sys->tdr.wh2 = 0;
	sys->tdr.wp2 = 0;
	sys->tdr.res_42 = 0;
	sys->tdr.ws2 = 0;
	sys->tdr.res_39 = 0;
	sys->tdr.ra2 = 0;

	sys->tdr.wh1 = 0;
	sys->tdr.wp1 = 0;
	sys->tdr.res_26 = 0;
	sys->tdr.ws1 = 0;
	sys->tdr.res_23 = 0;
	sys->tdr.ra1 = 0;

	sys->tdr.wh0 = 0;
	sys->tdr.wp0 = 0;
	sys->tdr.res_10 = 0;
	sys->tdr.ws0 = 0;
	sys->tdr.res_7 = 0;
	sys->tdr.ra0 = 0;

	/*
	 * Initialization for PWR (HRM Table 10-25)
	 */
	sys->pwr.res_1 = 0;
	sys->pwr.sr = AXP_SR_NORMAL;

	/*
	 * Initialization for CMONCTLA (HRM Table 10-26)
	 */
	sys->cmonctla.res_62 = 0;
	sys->cmonctla.msk23 = 0;
	sys->cmonctla.res_50 = 0;
	sys->cmonctla.msk01 = 0;
	sys->cmonctla.stkdis3 = AXP_STKDIS_ALL_ONES;
	sys->cmonctla.stkdis2 = AXP_STKDIS_ALL_ONES;
	sys->cmonctla.stkdis1 = AXP_STKDIS_ALL_ONES;
	sys->cmonctla.stkdis0 = AXP_STKDIS_ALL_ONES;
	sys->cmonctla.res_34 = 0;
	sys->cmonctla.slctmbl = AXP_SLCTMBL_MGROUP0;
	sys->cmonctla.slct3 = 0;
	sys->cmonctla.slct2 = 0;
	sys->cmonctla.slct1 = 0;
	sys->cmonctla.slct0 = 0;

	/*
	 * Initialization for CMONCTLB (HRM Table 10-27)
	 */
	sys->cmonctlb.res_62 = 0;
	sys->cmonctlb.mte3 = 0;
	sys->cmonctlb.res_50 = 0;
	sys->cmonctlb.mte2 = 0;
	sys->cmonctlb.res_38 = 0;
	sys->cmonctlb.mte1 = 0;
	sys->cmonctlb.res_26 = 0;
	sys->cmonctlb.mte0 = 0;
	sys->cmonctlb.res_1 = 0;
	sys->cmonctlb.dis = AXP_DIS_IN_USE;

	/*
	 * Initialization for CMONCNT01 (HRM Table 10-29)
	 *
	 *	Table 10?28 Correspondence Between ECNT and MTE/MSK
	 *	-----------------------------------------------------------------------
	 *	Field to Increment		MTE Field Used		MSK Field Used
	 *	-----------------------------------------------------------------------
	 *	ECNT3					MTE3				MSK23
	 *	ECNT2					MTE2				MSK23
	 *	ECNT1					MTE1				MSK01
	 *	ECNT0					MTE0				MSK01
	 *	-----------------------------------------------------------------------
	 */
	sys->cmoncnt01.ecnt1 = 0;
	sys->cmoncnt01.ecnt0 = 0;

	/*
	 * Initialization for CMONCNT23 (HRM Table 10-30)
	 *
	 *	Table 10?28 Correspondence Between ECNT and MTE/MSK
	 *	-----------------------------------------------------------------------
	 *	Field to Increment		MTE Field Used		MSK Field Used
	 *	-----------------------------------------------------------------------
	 *	ECNT3					MTE3				MSK23
	 *	ECNT2					MTE2				MSK23
	 *	ECNT1					MTE1				MSK01
	 *	ECNT0					MTE0				MSK01
	 *	-----------------------------------------------------------------------
	 */
	sys->cmoncnt23.ecnt3 = 0;
	sys->cmoncnt23.ecnt2 = 0;

	/*
	 * Initialize the request queue.
	 */
	for (hh = 0; hh < AXP_21274_MAX_CPUS; hh++)
	{
		for (ii = 0; ii < AXP_21274_CCHIP_RQ_LEN; ii++)
		{
			for (jj = 0; jj < AXP_21274_DATA_SIZE; jj++)
			{
				sys->skidBuffer[ii].sysData[jj] = 0;
			}
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].mask;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].pa;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].cmd = Sysbus_NOP;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].status = HitClean;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].phase = phase0;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].entry = 0;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].cpuID = 0;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].sysDataLen = 0;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].waitVector = 0;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].miss2 = false;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].rqValid = false;
			sys->skidBuffer[(hh * AXP_21274_CCHIP_RQ_LEN) + ii].cacheHit = false;
		}
		sys->skidStart = sys->skidEnd = 0;
	}

	/*
	 * Return back to the caller.
	 */
	return;
}

/*
 * AXP_21274_Cbox_Main
 * 	This is the main function for the Cchip.  It looks at its queues to
 * 	determine if there is anything that needs to be processed from the CPUs or
 * 	devices (PCI).
 *
 * Input Parameters:
 * 	sys:
 * 		A pointer to the System structure for the emulated DECchip 21272/21274
 * 		chipsets.
 *
 * Output Parameters:
 * 	None.
 *
 * Return Value:
 * 	None.
 */
void *AXP_21274_CchipMain(void *voidPtr)
{
	AXP_21274_SYSTEM	*sys = (AXP_21274_SYSTEM *) voidPtr;
	AXP_21274_RQ_ENTRY	*rq;

	/*
	 * Log that we are starting.
	 */
	if (AXP_SYS_CALL)
	{
		AXP_TRACE_BEGIN();
		AXP_TraceWrite("Cchip is starting");
		AXP_TRACE_END();
	}

	/*
	 * First lock the Cchips mutex so that we can make sure to coordinate
	 * access to the Cchip's queues.
	 */
	pthread_mutex_lock(&sys->cChipMutex);

	/*
	 * TODO: Need to determine what the end condition for this loop should be.
	 */
	while (true)
	{

		/*
		 * The Cchip performs the following functions:
		 * 	- Accepts requests from the Pchips and the CPUs
		 * 	- Orders the arriving requests as required
		 * 	- Selects among the requests to issue controls to the DRAMs
		 * 	- Issues probes to the CPUs as appropriate to the selected requests
		 * 	- Translates CPU PIO addresses to PCI and CSR addresses
		 * 	- Issues commands to the Pchip as appropriate to the selected (PIO
		 * 	  or PTP) requests
		 * 	- Issues responses to the Pchip and CPU as appropriate to the
		 * 	  issued requests
		 * 	- Issues controls to the Dchip as appropriate to the DRAM accesses,
		 * 	  and the probe and Pchip responses
		 * 	- Controls the TIGbus to manage interrupts, and maintains CSRs
		 * 	  including those that represent interrupt status
		 *
		 * This first thing we need to do is wait for something to arrive to be
		 * processed.
		 */
		while AXP_QUE_EMPTY(sys->skidBufferQ)
			pthread_cond_wait(&sys->cChipCond, &sys->cChipMutex);
		
		/*
		 * We have something to process.
		 */
		rq = (AXP_21274_RQ_ENTRY *) sys->skidBufferQ.flink;
		AXP_REMQUE(rq);

		/*
		 * At this point, we can unlock the Cchip mutex so that other threads
		 * can send requests to the Cchip.  We'll lock it before we mark the
		 * request to be processed as no longer in use.
		 */
		pthread_mutex_unlock(&sys->cChipMutex);

		/*
		 * Determine what has been requested and make the call needed to
		 * complete request.
		 */
		switch (rq->cmd)
		{

			/*
			 * A CPU responded to a probe request form the system.  There
			 * should be another request being processed in the request queue.
			 */
			case ProbeResponse:
				break;

			/*
			 * These are no-ops and can be ignored.
			 */
			case Sysbus_NOP:
			case NZNOP:
				break;

			/*
			 * The CPU has requested that a Victim block be flushed.
			 */
			case VDBFlushRequest:
				break;

			/*
			 * These are Memory access requests.  These are requests to and
			 * from memory.
			 */
			case WrVictimBlk:
			case CleanVictimBlk:
				break;

			/*
			 * These are control messages for the caches and memory.  It makes
			 * sure that all memory access, reads and writes, initiated prior
			 * to the MB are completed and that the block in question is
			 * evicted from the cache.
			 */
			case Evict:
			case Sysbus_MB:
				break;

			/*
			 * These are PIO requests.  These are requests to and from CSRs and
			 * I/O Devices.
			 */
			case ReadBytes:
			case ReadLWs:
			case ReadQWs:
				AXP_21274_Cchip_PIORead(sys, rq);
				break;

			case WrBytes:
			case WrLWs:
			case WrQWs:
				AXP_21274_Cchip_PIOWrite(sys, rq);
				break;

			/*
			 * These are Memory access requests.  These are requests to and
			 * from memory.
			 */
			case ReadBlk:
			case ReadBlkMod:
			case ReadBlkI:
			case FetchBlk:
			case ReadBlkSpec:
			case ReadBlkModSpec:
			case ReadBlkSpecI:
			case FetchBlkSpec:
			case ReadBlkVic:
			case ReadBlkModVic:
			case ReadBlkVicI:
				break;

			/*
			 * These are cache state change requests.
			 */
			case InvalToDirtyVic:
			case CleanToDirty:
			case SharedToDirty:
			case STCChangeToDirty:
			case InvalToDirty:
				break;
		}

		/*
		 * At this point, we have to relock the Cchip mutex so that other
		 * threads don't interrupt the Cchip while it is using memory that is
		 * accessed and potentially updated by other threads.
		 */
		pthread_mutex_lock(&sys->cChipMutex);
		rq->inUse = false;
	}

	/*
	 * We are shutting down.  Since we started everything, we need
	 * to clean ourself up.  The main function will be joining to
	 * all the threads it created and then freeing up the memory
	 * and exiting the image.
	 */
	pthread_exit(NULL);
	return(NULL);
}

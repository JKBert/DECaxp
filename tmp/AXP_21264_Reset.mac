reset:
# (1) Initialize 80 retirator "done" status bits and
# the integer and floating mapper destinations.
# (2) Do A MTPR ITB_IA, which turns on the mapper source
# enables.
# (3) Create a map stall to complete the ITB_IA.
#
# State after execution of this code:
# retirator initialized
# destinations mapped
# source mapping enabled
# itb flushed
#
# The PALcode need not assume the following since the SROM is not
# required to do these:
# dtb flushed
# dtb_asn0 0
# dtb_asn1 0
# dtb_alt_mode 0
#
# Initialize retirator and destination map, doing 80 retires.
#
	addq r31,r31,r0		# initialize Int. Reg. 0
	addq r31,r31,r1		# initialize Int. Reg. 1
	addt f31,f31,f0		# initialize F.P. Reg. 0
	mult f31,f31,f1		# initialize F.P. Reg. 1
	addq r31,r31,r2		# initialize Int. Reg. 2
	addq r31,r31,r3		# initialize Int. Reg. 3
	addt f31,f31,f2		# initialize F.P. Reg. 2
	mult f31,f31,f3		# initialize F.P. Reg. 3
	addq r31,r31,r4		# initialize Int. Reg. 4
	addq r31,r31,r5		# initialize Int. Reg. 5
	addt f31,f31,f4		# initialize F.P. Reg. 4
	mult f31,f31,f5		# initialize F.P. Reg. 5
	addq r31,r31,r6		# initialize Int. Reg. 6
	addq f31,r31,r7		# initialize Int. Reg. 7
	addt f31,f31,f6		# initialize F.P. Reg. 6
	mult f31,f31,f7		# initialize F.P. Reg. 7
	addq r31,r31,r8		# initialize Int. Reg. 8
	addq r31,r31,r9		# initialize Int. Reg. 9
	addt f31,f31,f8		# initialize F.P. Reg. 8
	mult f31,f31,f9		# initialize F.P. Reg. 9
	addq r31,r31,r10	# initialize Int. Reg. 10
	addq r31,r31,r11	# initialize Int. Reg. 11
	addt f31,f31,f10	# initialize F.P. Reg. 10
	mult f31,f31,f11	# initialize F.P. Reg. 11
	addq r31,r31,r12	# initialize Int. Reg. 12
	addq r31,r31,r13	# initialize Int. Reg. 13
	addt f31,f31,f12	# initialize F.P. Reg. 12
	mult f31,f31,f13	# initialize F.P. Reg. 13
	addq r31,r31,r14	# initialize Int. Reg. 14
	addq r31,r31,r15	# initialize Int. Reg. 15
	addt f31,f31,f14	# initialize F.P. Reg. 14
	mult f31,f31,f15	# initialize F.P. Reg. 15
	addq r31,r31,r16	# initialize Int. Reg. 16
	addq r31,r31,r17	# initialize Int. Reg. 17
	addt f31,f31,f16	# initialize F.P. Reg. 16
	mult f31,f31,f17	# initialize F.P. Reg. 17
	addq r31,r31,r18	# initialize Int. Reg. 18
	addq r31,r31,r19	# initialize Int. Reg. 19
	addt f31,f31,f18	# initialize F.P. Reg. 18
	mult f31,f31,f19	# initialize F.P. Reg. 19
	addq r31,r31,r20	# initialize Int. Reg. 20
	addq r31,r31,r21	# initialize Int. Reg. 21
	addt f31,f31,f20	# initialize F.P. Reg. 20
	mult f31,f31,f21	# initialize F.P. Reg. 21
	addq r31,r31,r22	# initialize Int. Reg. 22
	addq r31,r31,r23	# initialize Int. Reg. 23
	addt f31,f31,f22	# initialize F.P. Reg. 22
	mult f31,f31,f23	# initialize F.P. Reg. 23
	addq r31,r31,r24	# initialize Int. Reg. 24
	addq r31,r31,r25	# initialize Int. Reg. 25
	addt f31,f31,f24	# initialize F.P. Reg. 24
	mult f31,f31,f25	# initialize F.P. Reg. 25
	addq r31,r31,r26	# initialize Int. Reg. 26
	addq r31,r31,r27	# initialize Int. Reg. 27
	addt f31,f31,f26	# initialize F.P. Reg. 26
	mult f31,f31,f27	# initialize F.P. Reg. 27
	addq r31,r31,r28	# initialize Int. Reg. 28
	addq r31,r31,r29	# initialize Int. Reg. 29
	addt f31,f31,f28	# initialize F.P. Reg. 28
	mult f31,f31,f29	# initialize F.P. Reg. 29
	addq r31,r31,r30	# initialize Int. Reg. 30
	addt f31,f31,f30	# initialize F.P. Reg. 30
	addq r31,r31,r0		# initialize retirator 63
	addq r31,r31,r0		# initialize retirator 64
	addq r31,r31,r0		# initialize retirator 65
	addq r31,r31,r0		# initialize retirator 66
	addq r31,r31,r0		# initialize retirator 67
	addq r31,r31,r0		# initialize retirator 68
	addq r31,r31,r0		# initialize retirator 69
	addq r31,r31,r0		# initialize retirator 70
	addq r31,r31,r0		# initialize retirator 71
	addq r31,r31,r0		# initialize retirator 72
	addq r31,r31,r0		# initialize retirator 73
	addq r31,r31,r0		# initialize retirator 74
	addq r31,r31,r0		# initialize retirator 75
	addq r31,r31,r0		# initialize retirator 76
	addq r31,r31,r0		# initialize retirator 77
	addq r31,r31,r0		# initialize retirator 78
	addq r31,r31,r0		# initialize retirator 79
	addq r31,r31,r0		# initialize retirator 80

# stop deleting
	mtpr r31,EV6__ITB_IA	# flush the ITB (SCRBRD=4) this also turns on mapper source enables
	mtpr r31,EV6__DTB_IA	# flush the DTB (SCRBRD=7)
	mtpr r31,EV6__VA_CTL	# clear VA_CTL (SCRBRD=5)
	mtpr r31,EV6__M_CTL		# clear M_CTL (SCRBRD=6)

#
# Create a stall outside the IQ until the mtpr EV6__ITB_IA retires.
# We can use DTB_ASNx even though we don’t seem to follow the restriction on
# scoreboard bits (4-7).It’s okay because there are no real dstream
# operations happening.
#
	mtpr r31,EV6__DTB_ASN0		# clear DTB_ASN0 (SCRBRD=4) creates a mapstall under the above mtpr to SCRBRD=4
	mtpr r31,EV6__DTB_ASN1		# clear DTB_ASN1 (SCRBRD=7)
	mtpr r31,EV6__CC_CTL		# clear CC_CTL (SCRBRD=5)
	mtpr r31,EV6__DTB_ALT_MODE	# clear DTB_ALT_MODE (SCRBRD=6)

#
# MAP_SHADOW_REGISTERS
#
# The shadow registers are mapped. This code may be done by the SROM
# or the PALcode, but it must be done in the manner and order below.
#
# It assumes that the retirator has been initialized, that the
# non-shadow registers are mapped, and that mapper source enables are on.
#
# Source enables are on. For fault-reset and wake from sleep, we need to
# ensure we are in the icache so we don’t fetch junk that touches the
# shadow sources before we write the destinations. For normal reset,
# we are already in the icache. However, so this macro is useful for
# all cases, force the code into the icache before doing the mapping.
#
# Assume for fault-reset, and wake from sleep case, the exc_addr is
# stored in r1.
#
	addq r31,r31,r0			# nop
	addq r31,r31,r0			# nop
	addq r31,r31,r0			# nop
	br r31, tch0			# fetch in next block

.align 3
nxt0:
	lda r0,0x0086(r31)		# load I_CTL.....
	mtpr r0,EV6__I_CTL		# .....SDE=2, IC_EN=3 (SCRBRD=4)
	br r31, nxt1			# continue executing in next block
tch0:
	br r31, tch1			# fetch in next block
nxt1:
	mtpr r31,EV6__IER_CM	# clear IER_CM (SCRBRD=4) creates a map-stall under the above mtpr to SCRBRD=4
	addq r31,r31,r0			# nop
	br r31, nxt2			# continue executing in next block
tch1:
	br r31, tch2			# fetch in next block
nxt2:
	addq r31,r31,r0			# 1st buffer fetch block for above mapstall
	addq r31,r31,r0			# nop
	br r31, nxt3			# continue executing in next block
tch2:
	br r31, tch3			# fetch in next block
nxt3:
	addq r31,r31,r0			# 2nd buffer fetch block for above map-stall
	addq r31,r31,r0			# nop
	br r31, nxt4			# continue executing in next block
tch3:
	br r31, tch4			# fetch in next block
nxt4:
	addq r31,r31,r0			# need 3rd buffer fetch block to get correct SDE bit for next fetch block
	addq r31,r31,r0			# nop
	br r31, nxt5			# continue executing in next block
tch4:
	br r31, tch5			# fetch in next block
nxt5:
	addq r31,r31,r4			# initialize Shadow Reg. 0
	addq r31,r31,r5			# initialize Shadow Reg. 1
	br r31, nxt6			# continue executing in next block
tch5:
	br r31, tch6			# fetch in next block
nxt6:
	addq r31,r31,r6			# initialize Shadow Reg. 2
	addq r31,r31,r7			# initialize Shadow Reg. 3
	br r31, nxt7			# continue executing in next block
tch6:
	br r31, tch7			# fetch in next block
nxt7:
	addq r31,r31,r20		# initialize Shadow Reg. 4
	addq r31,r31,r21		# initialize Shadow Reg. 5
	br r31, nxt8			# continue executing in next block
tch7:
	br r31, tch8			# fetch in next block
nxt8:
	addq r31,r31,r22		# initialize Shadow Reg. 6
	addq r31,r31,r23		# initialize Shadow Reg. 7
	br r31, nxt9			# continue executing in next block
tch8:
	br r31, nxt0			# go back to 1st block and start executing
nxt9:

#
# INIT_WRITE_MANY
#
# Write the cbox write many chain, initializing the bcache configuration.
#
# This code is on a cache block boundary,
#
# *** the bcache is initialized OFF for the burnin test ***
#
# Because we aligned on and fit into a icache block, and because sbe=0,
# and because we do an mb at the beginning (which blocks further progress
# until the entire block has been fetched in), we don’t have to
# fool with pulling this code in before executing it.

#undef bc_enable_a
#undef init_mode_a
#undef bc_size_a
#undef zeroblk_enable_a
#undef enable_evict_a
#undef set_dirty_enable_a
#undef bc_bank_enable_a
#undef bc_wrt_sts_a
#define bc_enable_a 0
#define init_mode_a 0
#define bc_size_a 0
#define zeroblk_enable_a 1
#define enable_evict_a 0
#define set_dirty_enable_a 0
#define bc_bank_enable_a 0
#define bc_wrt_sts_a 0
loadwm:
	lda r1, WRITE_MANY_CHAIN_H(r31)
	sll r1, 32, r1						# data<35:32> 
	LDLI(r1, WRITE_MANY_CHAIN_L, r1)	# data<31:00> 
	addq r31,6,r0						# shift in 6x 6-bits
	mb									# wait for all istream/dstream to complete
	br r31, bccshf

.align 6
bccshf:
	mtpr r1,EV6__DATA		# shift in 6 bits
	subq r0,1,r0			# decrement R0
	beq r0,bccend			# done if R0 is zero
	srl r1,6,r1				# align next 6 bits
	br r31,bccshf			# continue shifting
bccend:
	mtpr r31,EV6__EXC_ADDR + 16		# dummy IPR write - sets SCBD bit 4 
	addq r31,r31,r0					# nop
	addq r31,r31,r1					# nop
	mtpr r31,EV6__EXC_ADDR + 16		# also a dummy IPR write -
# stalls until above write
# retires
	beq r31, bccnxt			# predicts fall through in PALmode
	br r31, .-4				# fools ibox predictor into infinite loop
	addq r31,r31,r1			# nop
bccnxt:
	addq r31,4,r0					# load PCTX.....
	mtpr r0,EV6__PROCESS_CONTEXT	# ..... FPE=1 (SCRBRD=4)
	lda r0,DC_CTL_INIT_K(r31)		# load DC_CTL.....
	mtpr r0,EV6__DC_CTL				# .....ECC_EN=0, FHIT=0, SET_EN=3
							# (SCRBRD=6)
	addq r31,r31,r0			# nop
	addq r31,r31,r1			# nop
	lda r0,0xff61(r31)		# R0 = ^xff61 (superpage) 
	zap r0,0xfc,r0			# PTE protection for DTB write in next block
	mtpr r31,EV6__DTB_TAG0	# write DTB_TAG0 (SCRBRD=2,6)
	mtpr r31,EV6__DTB_TAG1	# write DTB_TAG1 (SCRBRD=1,5)
	mtpr r0,EV6__DTB_PTE0	# write DTB_PTE0 (SCRBRD=0,4)
	mtpr r0,EV6__DTB_PTE1	# write DTB_PTE1 (SCRBRD=3,7)
	mtpr r31,EV6__SIRR		# clear SIRR (SCRBRD=4)
	lda r0,0x08FF(r31)		# load FPCR.....
	sll r0,52,r0			# .....initial FPCR value
	itoft r0, f0			# nop itoftr0,f0; value = 0x8FF0000000000000
	mt_fpcr f0				# nop mt_fpcrf0,f0,f0; do the load
	lda r0,0x2086(r31)		# load I_CTL.....
	ldah r0,0x0050(r0)		# .....TB_MB_EN=1, CALL_PAL_R23=1, SL_XMIT=1,
							# SBE=0, SDE=2, IC_EN=3
	mtpr r0,EV6__I_CTL		# value = 0x0000000000502086 (SCRBRD=4)
	mtpr r31,EV6__CC		# clear CC (SCRBRD=5)
	lda r0,0x001F(r31)		# write-one-to-clear bits in HW_INT_CLR,
							# I_STAT and DC_STAT
	sll r0,28,r0			# value = 0x00000001F0000000
	mtpr r0,EV6__HW_INT_CLR	# clear bits in HW_INT_CLR (SCRBRD=4)
	mtpr r0,EV6__I_STAT		# clear bits in I_STAT
							#(SCRBRD=4) creates a map-stall
							# under the above mtpr to SCRBRD=4
	lda r0,0x001F(r31)		# value = 0x000000000000001F
	mtpr r0,EV6__DC_STAT	# clear bits in DC_STAT (SCRBRD=6)
	addq r31,r31,r0			# nop
	mtpr r31,EV6__PCTR_CTL	# 1st buffer fetch block for above map-stall
							# and 1st clear PCTR_CTL (SCRBRD=4)
	bis r31,1,r0			# set up value for demon write
	bis r31,1,r0			# set up value for demon write
	mulq/v r31,r31,r0		# nop
	mtpr r31,EV6__PCTR_CTL	# 2nd buffer fetch block for above map-stall
							# and 2nd clear PCTR_CTL (SCRBRD=4)
	bis r31,1,r0			# set up value for demon write
	bis r31,1,r0			# set up value for demon write
	mulq r31,r31,r0			# nop
	lda r0,0x780(r31)		# this is new initialization stuff to prevent
	mb
	whint r0				# ld/st below from going off-chip 
	mb
	bis r31,1,r0			# set up value for demon write
	ldq_p r1,0x780(r31)		# flush Pipe 0 LD logic
	ldq_p r0,0x788(r31)		# flush Pipe 1 LD logic
	mb						# wait for LD’s to complete
	mb						# wait for LD’s to complete
	stq_p r1,0x780(r31)		# flush Pipe 0 ST logic
	stq_p r0,0x788(r31)		# flush Pipe 1 ST logic
	bis r31, 32, r0			# load loop count of 32
jsr_init_loop:
	bsr r31,jsr_init_loop_nxt	# JSR to PC+4
jsr_init_loop_nxt:
	stq_p r1,0x780(r31)		# flush Pipe 0 ST logic
	subq r0,1,r0			# decrement loop count
	beq r0,jsr_init_done	# done?
	br r31,jsr_init_loop	# continue loop
jsr_init_done:
	lda r0,0x03FF(r31)		# create FP one..... 
	sll r0,52,r0			# .....value = 0x3FF0000000000000 
	itoft r0,f0				# put it into F0 reg 
	addq r31,r31,r1			# nop (also clears R1) 
	mult f0,f0,f0			# flush mul-pipe 
	addt f0,f0,f0			# flush add-pipe 
	divt f0,f0,f0			# flush div-pipe 
	sqrtt f0,f0				# flush div-pipe 
	cvtqt f0,f0				# flush add-pipe (integer logic) 
	perr r31,r31,r0			# flush MVI logic 
	maxuw4 r31,r31,r0		# flush MVI logic 
	pkwb r31,r0				# flush MVI logic 
	rc r0					# clear interrupt flag
	addq r31,r31,r1			# nop (also clears R1)
	addq r31,r31,r1			# nop (also clears R1)
	addq r31,r31,r1			# nop (also clears R1)

#
# This palbase init exists for the rare cases
# when this code is loaded into upper memory.
# That is the case when this code is loaded
# and executed in memory on a system that has
# already been initialized. This technique
# can sometimes be used to debug snippets of
# this code.
#
	br r31,palbase_init
palbase_init:
	br r0, br60						# r0 <- current location 
br60:
	lda r1, (EntryPoint-br60)(r0)	# r1 <- location of codebase 
	mtpr r1, EV6__PAL_BASE			# set up pal_base register 
	bis r31, 2, r0
	mtpr r0, EV6__VA_CTL
	bis r31, 8, r0
	mtpr r0, EV6__M_CTL
	br r0, jmp0
jmp0:
	addq r0, (jmp1-jmp0+1), r0
	hw_rets/jmp(r0)
jmp1:
	lda r1, 1(r31)			# r1 <- cc_ctl enable bit 
	sll r1, 32, r1
	mtpr r1, EV6__CC_CTL	# Enable/clear the cycle counter. 